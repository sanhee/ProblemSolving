## 문제 정리
- **입력**: 정수 `N` (1 ≤ N ≤ 10⁹)
- **초기 상태**: 길이 `N`짜리 문자열이 모두 `'a'`로 이루어져 있음
- **허용 연산**: 인접한 같은 문자 두 개를 하나의 다음 알파벳 문자로 병합
    - 예) `"aa"` → `"b"`, `"cc"` → `"d"`, …, `"yy"` → `"z"`
    - `"zz"`은 더 이상 변환 불가
- **목표**: 여러 번 연산을 적용했을 때 얻을 수 있는 문자열 중 **사전 순(알파벳 순)으로 가장 뒤**에 오는 문자열을 반환

## 핵심 아이디어
1. `'a'`에서 k단계 올라간 문자(`'a' + k`)를 만들려면 **2ᵏ**개의 `'a'`가 필요
2. 가장 큰 문자인 `'z'`(k = 25)부터 `'a'`(k = 0)까지 **그리디**하게 처리
    1. 현재 남은 `N`에서 `2ᵏ`이 몇 번 들어가는지 계산 (`count = N / 2ᵏ`)
    2. 그 횟수만큼 해당 문자를 결과에 추가
    3. 사용한 만큼을 `N %= 2ᵏ`로 남은 `N`에서 제거
3. 총 26단계만 반복해도 최적의 사전순 최대 문자열을 얻을 수 있음

## 시간 복잡도
- 외부 루프: **26회** (k = 25 → 0)
- 내부 `append` 연산: 결과 문자열 길이만큼 (최대 ≈ 30~60자)  
  → 전체적으로 **O(1)**(사실상 상수 시간)

## 공간 복잡도
- 결과 문자열 길이: **O(log N)** (최대 ≈ 30~60 문자)
- 추가 변수: **O(1)**
