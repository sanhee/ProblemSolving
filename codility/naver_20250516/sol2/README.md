## 문제 정리

- **입력**
    - 길이 \(N\)인 이진 문자열 `S` (맨 앞이 최상위 비트, leading zero 허용)
- **출력**
    - 값 \(V\)를 0으로 만들기 위해 수행한 연산 횟수
        1. \(V\)가 **짝수**일 때 → \(V \gets V / 2\)
        2. \(V\)가 **홀수**일 때 → \(V \gets V - 1\)
- **제약 사항**
    - \(1 \le N \le 1\,000\,000\)
    - 시간 복잡도 \(O(N)\), 추가 공간 \(O(1)\) 으로 해결해야 함

---

## 핵심 아이디어

1. **최상위 ‘1’ 위치 찾기**
    - `firstOne = S.indexOf('1')`
    - 만약 `firstOne == -1` 이면 모두 0이므로 **0회** 연산

2. **첫 ‘1’ 제거**
    - 첫 번째 ‘1’ 비트를 0으로 만드는 연산(−1) → `ops += 1`

3. **나머지 비트별로 연산 횟수 누적**
    - `for (i = firstOne+1; i < N; i++)`
        - `S.charAt(i) == '0'` → 짝수 단계 → ÷2 **1회** → `ops += 1`
        - `S.charAt(i) == '1'` → 홀수 단계 → −1+÷2 **2회** → `ops += 2`

4. **총 연산 횟수**  
   \[
   \text{ops}
   = 1\;(\text{첫 ‘1’ 제거})
    + \sum_{i=\text{firstOne}+1}^{N-1}
      \bigl(\,S[i]=='0'?1:2\bigr)
      \]

5. **시간·공간 복잡도**
    - 한 번만 문자열 순회 → **O(N)**
    - 추가 변수만 사용 → **O(1)**

---

```java
// 핵심 구현
int firstOne = S.indexOf('1');
if (firstOne == -1) return 0;

int ops = 1;  // 첫 번째 ‘1’ 제거
for (int i = firstOne + 1; i < S.length(); i++) {
    ops += (S.charAt(i) == '0' ? 1 : 2);
}
return ops;
